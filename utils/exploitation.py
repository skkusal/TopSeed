import numpy as np
from collections import defaultdict
from sklearn.cluster import KMeans

def select(ds_bucket, policy):
    kmeans = KMeans(n_clusters=2, random_state=0)
    usedSeeds = ds_bucket['usedSeeds']

    branchFreq = defaultdict(int)
    for key, each in usedSeeds.items():
        covSet = each[1]

        for eachCovSet in covSet:
            branchFreq[eachCovSet] += 1

    scores = []
    scores2 = []
    
    i = 0
    for key, each in usedSeeds.items():
        seed = key
        pc, covSet = each[0], each[1]

        score = 0.0
        for eachCovSet in covSet:
            score += 1 / branchFreq[eachCovSet]

        scores2.append([0, score])
        scores.append([i, score, seed, pc])
        i += 1

    X = np.array(scores2)
    Y = np.array(scores)
    kmeans.fit(X)

    labels = kmeans.labels_ 

    firstData = Y[labels == 0]
    secondData = Y[labels == 1]

    maxFirData = max(firstData, key=lambda x: x[1])
    maxSecData = max(secondData, key=lambda x: x[1])

    if maxFirData[1] < maxSecData[1]:
        filteredTopData = secondData
        filteredBotData = firstData
    else:
        filteredTopData = firstData
        filteredBotData = secondData

    indexes = []
    k = 0
    for each in filteredTopData:
        indexes.append(k)
        k += 1

    if len(filteredTopData) == 1:
        reusedSeed = filteredTopData[0][2]
    else:
        if policy == "Rand":
            reusedSeed = filteredTopData[np.random.choice(indexes)][2]

        elif policy == "Uniq":
            pcUniqueness = dict()
            bestUniq = -1e10
            for eachSeed1 in filteredTopData:
                seed1, pc1 = eachSeed1[2], eachSeed1[3]
                
                uniq = set()
                for eachSeed2 in filteredTopData:
                    if eachSeed1[2] == eachSeed2[2]:
                        continue

                    seed2, pc2 = eachSeed2[2], eachSeed2[3]
                    uniq |= pc2

                pcUniqueness[seed1] = len(pc1 - uniq)

                if bestUniq < len(pc1 - uniq):
                    bestUniq = len(pc1 - uniq)
                    reusedSeed = seed1

        elif policy == "Long":
            bestLong = -1e10
            for eachSeed in filteredTopData:
                seed1, pc1 = eachSeed[2], eachSeed[3]

                if bestLong < len(pc1):
                    bestLong = len(pc1)
                    reusedSeed = seed1

        else:
            bestShort = 1e10
            for eachSeed in filteredTopData:
                seed1, pc1 = eachSeed[2], eachSeed[3]

                if bestShort > len(pc1):
                    bestShort = len(pc1)
                    reusedSeed = seed1

    return reusedSeed